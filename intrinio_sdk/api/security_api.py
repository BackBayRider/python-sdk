# coding: utf-8

"""
    Intrinio API

    Welcome to the Intrinio API! Through our Marketplace, we offer a wide selection of financial data feeds sourced by our own proprietary processes as well as from many data vendors. The primary application of the Intrinio API is for use in third-party applications and integrations or for end-users utilizing the Excel add-in and Google Sheets add-on. The Intrinio API uses HTTPS verbs and a RESTful endpoint structure, which makes it easy to request data from Intrinio. Responses are delivered in JSON format. If you need additional help in using the API, go to our home page (https://intrinio.com) and click on the chat icon in the lower right corner.  # noqa: E501

    OpenAPI spec version: 2.0.1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from intrinio_sdk.api_client import ApiClient


class SecurityApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_all_securities(self, **kwargs):  # noqa: E501
        """Get All Securiites  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_all_securities(async=True)
        >>> result = thread.get()

        :param async bool
        :param str next_page: Gets the next page of data from a previous API call
        :return: list[SecuritySummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_all_securities_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_securities_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_securities_with_http_info(self, **kwargs):  # noqa: E501
        """Get All Securiites  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_all_securities_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str next_page: Gets the next page of data from a previous API call
        :return: list[SecuritySummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_securities" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HttpHeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/securities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SecuritySummary]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_security_by_id(self, identifier, **kwargs):  # noqa: E501
        """Get a Security by ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_security_by_id(identifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str identifier: A Security identifier (Ticker, FIGI, ISIN, CUSIP, Intrinio ID) (required)
        :return: Security
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_security_by_id_with_http_info(identifier, **kwargs)  # noqa: E501
        else:
            (data) = self.get_security_by_id_with_http_info(identifier, **kwargs)  # noqa: E501
            return data

    def get_security_by_id_with_http_info(self, identifier, **kwargs):  # noqa: E501
        """Get a Security by ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_security_by_id_with_http_info(identifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str identifier: A Security identifier (Ticker, FIGI, ISIN, CUSIP, Intrinio ID) (required)
        :return: Security
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['identifier']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'identifier' is set
        if ('identifier' not in params or
                params['identifier'] is None):
            raise ValueError("Missing the required parameter `identifier` when calling `get_security_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'identifier' in params:
            path_params['identifier'] = params['identifier']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HttpHeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/securities/{identifier}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Security',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_security_data_point_number(self, identifier, item, **kwargs):  # noqa: E501
        """Get Security Data Point (Number)  # noqa: E501

        Returns a numeric value for the given `item` for the Security with the given `identifier`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_security_data_point_number(identifier, item, async=True)
        >>> result = thread.get()

        :param async bool
        :param str identifier: A Security identifier (Ticker, FIGI, ISIN, CUSIP, Intrinio ID) (required)
        :param str item: An Intrinio data tag or other item (required)
        :return: DataPointNumber
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_security_data_point_number_with_http_info(identifier, item, **kwargs)  # noqa: E501
        else:
            (data) = self.get_security_data_point_number_with_http_info(identifier, item, **kwargs)  # noqa: E501
            return data

    def get_security_data_point_number_with_http_info(self, identifier, item, **kwargs):  # noqa: E501
        """Get Security Data Point (Number)  # noqa: E501

        Returns a numeric value for the given `item` for the Security with the given `identifier`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_security_data_point_number_with_http_info(identifier, item, async=True)
        >>> result = thread.get()

        :param async bool
        :param str identifier: A Security identifier (Ticker, FIGI, ISIN, CUSIP, Intrinio ID) (required)
        :param str item: An Intrinio data tag or other item (required)
        :return: DataPointNumber
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['identifier', 'item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_data_point_number" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'identifier' is set
        if ('identifier' not in params or
                params['identifier'] is None):
            raise ValueError("Missing the required parameter `identifier` when calling `get_security_data_point_number`")  # noqa: E501
        # verify the required parameter 'item' is set
        if ('item' not in params or
                params['item'] is None):
            raise ValueError("Missing the required parameter `item` when calling `get_security_data_point_number`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'identifier' in params:
            path_params['identifier'] = params['identifier']  # noqa: E501
        if 'item' in params:
            path_params['item'] = params['item']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HttpHeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/securities/{identifier}/data_point/{item}/number', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataPointNumber',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_security_data_point_text(self, identifier, item, **kwargs):  # noqa: E501
        """Get Security Data Point (Text)  # noqa: E501

        Returns a text value for the given `item` for the Security with the given `identifier`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_security_data_point_text(identifier, item, async=True)
        >>> result = thread.get()

        :param async bool
        :param str identifier: A Security identifier (Ticker, FIGI, ISIN, CUSIP, Intrinio ID) (required)
        :param str item: An Intrinio data tag or other item (required)
        :return: DataPointText
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_security_data_point_text_with_http_info(identifier, item, **kwargs)  # noqa: E501
        else:
            (data) = self.get_security_data_point_text_with_http_info(identifier, item, **kwargs)  # noqa: E501
            return data

    def get_security_data_point_text_with_http_info(self, identifier, item, **kwargs):  # noqa: E501
        """Get Security Data Point (Text)  # noqa: E501

        Returns a text value for the given `item` for the Security with the given `identifier`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_security_data_point_text_with_http_info(identifier, item, async=True)
        >>> result = thread.get()

        :param async bool
        :param str identifier: A Security identifier (Ticker, FIGI, ISIN, CUSIP, Intrinio ID) (required)
        :param str item: An Intrinio data tag or other item (required)
        :return: DataPointText
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['identifier', 'item']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_data_point_text" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'identifier' is set
        if ('identifier' not in params or
                params['identifier'] is None):
            raise ValueError("Missing the required parameter `identifier` when calling `get_security_data_point_text`")  # noqa: E501
        # verify the required parameter 'item' is set
        if ('item' not in params or
                params['item'] is None):
            raise ValueError("Missing the required parameter `item` when calling `get_security_data_point_text`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'identifier' in params:
            path_params['identifier'] = params['identifier']  # noqa: E501
        if 'item' in params:
            path_params['item'] = params['item']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HttpHeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/securities/{identifier}/data_point/{item}/text', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataPointText',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_security_historical_data(self, identifier, item, **kwargs):  # noqa: E501
        """Get Security Historical Data  # noqa: E501

        Returns historical values for the given `item` and the Security with the given `identifier`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_security_historical_data(identifier, item, async=True)
        >>> result = thread.get()

        :param async bool
        :param str identifier: A Security identifier (Ticker, FIGI, ISIN, CUSIP, Intrinio ID) (required)
        :param str item: An Intrinio data tag or other item (required)
        :param str type: Filter by type, when applicable
        :param date start_date: Get historical data on or after this date
        :param date end_date: Get historical date on or before this date
        :param str sort_order: Sort by date `asc` or `desc`
        :param str next_page: Gets the next page of data from a previous API call
        :return: list[HistoricalData]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_security_historical_data_with_http_info(identifier, item, **kwargs)  # noqa: E501
        else:
            (data) = self.get_security_historical_data_with_http_info(identifier, item, **kwargs)  # noqa: E501
            return data

    def get_security_historical_data_with_http_info(self, identifier, item, **kwargs):  # noqa: E501
        """Get Security Historical Data  # noqa: E501

        Returns historical values for the given `item` and the Security with the given `identifier`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_security_historical_data_with_http_info(identifier, item, async=True)
        >>> result = thread.get()

        :param async bool
        :param str identifier: A Security identifier (Ticker, FIGI, ISIN, CUSIP, Intrinio ID) (required)
        :param str item: An Intrinio data tag or other item (required)
        :param str type: Filter by type, when applicable
        :param date start_date: Get historical data on or after this date
        :param date end_date: Get historical date on or before this date
        :param str sort_order: Sort by date `asc` or `desc`
        :param str next_page: Gets the next page of data from a previous API call
        :return: list[HistoricalData]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['identifier', 'item', 'type', 'start_date', 'end_date', 'sort_order', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_historical_data" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'identifier' is set
        if ('identifier' not in params or
                params['identifier'] is None):
            raise ValueError("Missing the required parameter `identifier` when calling `get_security_historical_data`")  # noqa: E501
        # verify the required parameter 'item' is set
        if ('item' not in params or
                params['item'] is None):
            raise ValueError("Missing the required parameter `item` when calling `get_security_historical_data`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'identifier' in params:
            path_params['identifier'] = params['identifier']  # noqa: E501
        if 'item' in params:
            path_params['item'] = params['item']  # noqa: E501

        query_params = []
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'sort_order' in params:
            query_params.append(('sort_order', params['sort_order']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HttpHeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/securities/{identifier}/historical_data/{item}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[HistoricalData]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_security_stock_prices(self, identifier, **kwargs):  # noqa: E501
        """Get Stock Prices for Security  # noqa: E501

        Return stock prices for the Security with the given `identifier`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_security_stock_prices(identifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str identifier: A Security identifier (Ticker, FIGI, ISIN, CUSIP, Intrinio ID) (required)
        :param date start_date: Return prices on or after the date
        :param date end_date: Return prices on or before the date
        :param str frequency: Return stock prices in the given frequency
        :param str next_page: Gets the next page of data from a previous API call
        :return: list[StockPriceSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.get_security_stock_prices_with_http_info(identifier, **kwargs)  # noqa: E501
        else:
            (data) = self.get_security_stock_prices_with_http_info(identifier, **kwargs)  # noqa: E501
            return data

    def get_security_stock_prices_with_http_info(self, identifier, **kwargs):  # noqa: E501
        """Get Stock Prices for Security  # noqa: E501

        Return stock prices for the Security with the given `identifier`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.get_security_stock_prices_with_http_info(identifier, async=True)
        >>> result = thread.get()

        :param async bool
        :param str identifier: A Security identifier (Ticker, FIGI, ISIN, CUSIP, Intrinio ID) (required)
        :param date start_date: Return prices on or after the date
        :param date end_date: Return prices on or before the date
        :param str frequency: Return stock prices in the given frequency
        :param str next_page: Gets the next page of data from a previous API call
        :return: list[StockPriceSummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['identifier', 'start_date', 'end_date', 'frequency', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_security_stock_prices" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'identifier' is set
        if ('identifier' not in params or
                params['identifier'] is None):
            raise ValueError("Missing the required parameter `identifier` when calling `get_security_stock_prices`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'identifier' in params:
            path_params['identifier'] = params['identifier']  # noqa: E501

        query_params = []
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'frequency' in params:
            query_params.append(('frequency', params['frequency']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HttpHeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/securities/{identifier}/prices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StockPriceSummary]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def screen_securities(self, **kwargs):  # noqa: E501
        """Screen Securities  # noqa: E501

        Screen securities using complex logic  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.screen_securities(async=True)
        >>> result = thread.get()

        :param async bool
        :param SecurityScreenGroup logic: The logic to screen with, consisting of operators, clauses, and nested groups
        :param str order_column: Results returned sorted by this column
        :param str order_direction: Sort order to use with the order_column
        :param bool primary_only: Return only primary securities
        :param str next_page: Gets the next page of data from a previous API call
        :return: list[SecurityScreenResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.screen_securities_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.screen_securities_with_http_info(**kwargs)  # noqa: E501
            return data

    def screen_securities_with_http_info(self, **kwargs):  # noqa: E501
        """Screen Securities  # noqa: E501

        Screen securities using complex logic  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.screen_securities_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param SecurityScreenGroup logic: The logic to screen with, consisting of operators, clauses, and nested groups
        :param str order_column: Results returned sorted by this column
        :param str order_direction: Sort order to use with the order_column
        :param bool primary_only: Return only primary securities
        :param str next_page: Gets the next page of data from a previous API call
        :return: list[SecurityScreenResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['logic', 'order_column', 'order_direction', 'primary_only', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method screen_securities" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'order_column' in params:
            query_params.append(('order_column', params['order_column']))  # noqa: E501
        if 'order_direction' in params:
            query_params.append(('order_direction', params['order_direction']))  # noqa: E501
        if 'primary_only' in params:
            query_params.append(('primary_only', params['primary_only']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'logic' in params:
            body_params = params['logic']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HttpHeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/securities/screen', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SecurityScreenResult]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_securities(self, query, **kwargs):  # noqa: E501
        """Search Securities  # noqa: E501

        Searches for Securities matching the text `query`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_securities(query, async=True)
        >>> result = thread.get()

        :param async bool
        :param str query: (required)
        :param str next_page: Gets the next page of data from a previous API call
        :return: list[SecuritySummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_securities_with_http_info(query, **kwargs)  # noqa: E501
        else:
            (data) = self.search_securities_with_http_info(query, **kwargs)  # noqa: E501
            return data

    def search_securities_with_http_info(self, query, **kwargs):  # noqa: E501
        """Search Securities  # noqa: E501

        Searches for Securities matching the text `query`  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_securities_with_http_info(query, async=True)
        >>> result = thread.get()

        :param async bool
        :param str query: (required)
        :param str next_page: Gets the next page of data from a previous API call
        :return: list[SecuritySummary]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['query', 'next_page']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_securities" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'query' is set
        if ('query' not in params or
                params['query'] is None):
            raise ValueError("Missing the required parameter `query` when calling `search_securities`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'next_page' in params:
            query_params.append(('next_page', params['next_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['HttpHeaderApiKey']  # noqa: E501

        return self.api_client.call_api(
            '/securities/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SecuritySummary]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
